Большинство программ для взлома и читинга условно можно разделить на два типа. 
Первый направлен на изменение каких-либо параметров непосредственно в игре (читерство). 
К таким программаv относятся трейнеры и редакторы сохранений. 
Второй же тип предназначен для извлечения различных ресурсов из игры: текстур, анимаций, звуковых файлов и прочего. 
Такой софт полезен для тех, кто создает моды. 
В этой статье предлагаю ознакомится с наиболее эффективными и простыми в использовании программами различных видов.
CheMax — это база данных с кодами, читами и хинтами для огромного количества игр с различных платформ. 
Программа имеет простой интерфейс, малый размер, регулярные обновления и бесплатную модель распространения, что делает ее незаменимой для любого игрока. 
Скачать CheMax можно с официального сайта.
Dragon UnPACKer — самая популярная программа для извлечения игровых элементов. 
С ее помощью можно не только вытянуть файлы, вроде картинок и музыки, но и преобразовать их в удобный для пользователя формат. 
Минусов у программы ровно два: довольно скромный список поддерживаемых игр (всего 80 штук) и высокая сложность в освоении. 
Скачать Dragon UnPACKer можно отсюда.
Game Audio Player выполняет схожие функции, что и Dragon UnPACKer, но работает исключительно со звуковыми файлами. 
Даже плеер есть. Скачать Game Audio Player можно отсюда.
Сохранение файлов и конвертирование в WAV-формат проводится в окне «Playlist» (иконка красного файла).
Реверсивная инженерия — изучение того, как устроено какое-то программное обеспечение, с целью понять механизм его работы. 
Эта информация может использоваться в будущем для создания похожего продукта или внесения изменения в уже существующий.
Я хочу рассказать о том, как с помощью реверсивной инженерии можно вносить изменения в игры на ПК. 
Не обязательно с целью взлома, иногда это используется для исправления багов, которые разработчики не исправили по каким-то причинам. 
Так, например, существует проект Forged Alliance Forever, будучи участником которого я исправил пару багов в игре Supreme Commander, которая пользуется большой популярностью до сих пор, но из-за проблем между издателем и разработчиком поддержка игры была прекращена.
Эта статья будет интересна тем, кто занимается разработкой программного обеспечения на языках высокого уровня и интересуется тем, как оно работает на более низком уровне. 
А также всем тем, кто просто любит игры и хочет знать об их устройстве больше.
Когда мы пишем какое-то ПО, то чаще всего, мы выбираем инструментарий, подходящий лучше всего под эту задачу. 
В современных играх код пишется на компилируемых языках высокого уровня. 
Конечно, можно вспомнить Minecraft на Java, который в конечном итоге все-таки переписали на плюсах.
Здесь стоит уточнить, что часто та часть приложения, которая критична для производительности, пишется на компилируемом языке, в то время как логика может быть на чем-то скриптовом, типа Lua, который уже обращается к ядру движка.
Код на языке высокого уровня с помощью компилятора превращается в машинный код, состоящий из инструкций для процессора определенной архитектуры. 
При запуске, процессор последовательно выполняет инструкции, а наше приложение работает.
Для того, чтобы внести изменения в ход работы программы, нам необходимо отредактировать эти самые инструкции. 
Для этого нам потребуется определенный инструментарий, позволяющий нам внедряться в работу программы. 
Основным инструментом нам послужит дебаггер, я пользуюсь x64dbg.
Дебаггер — программа, которая подключается к (например) игре и позволяет ковыряться в ней во время ее работы. 
Она позволяет выполнять инструкции последовательно, менять содержимое регистров и стека.
Регистры — это небольшие участки памяти процессора, которые он использует при выполнении команд. 
У каждого регистра есть своя задача, например, один используется для возвращаемого функцией значения, другой хранит в себе аргументы, а третий — следующую инструкцию, которая будет выполнена.
Стек используется для хранения информации, которая используется программой. 
Он нам мало интересен, кроме его особенности в хранении информации в упорядоченном виде.
Тут все предельно просто — находим ячейку в памяти, в которой хранится количество патронов или жизней, меняем на то, которое позволяет собственная жадность. 
Главное, чтобы жадность не превышала размер типа данных, иначе приложение рухнет. Этим многие из нас баловались еще во времена ArtMoney.
Здесь мы тоже получаем информацию о противниках из памяти игры, а разница между позицией игрока и противника и будет вектором, куда нам надо стрелять. 
Останется только повернуть игрока в нужном направлении, раз он сам не в состоянии.
Поскольку в реальной жизни отладка занимает просто колоссальное количество времени, мы опробуем свои силы на чем-то простом, чтобы уложиться в рамки статьи. 
У меня под рукой оказалась The Outer Worlds, над которой мы сегодня и будем паразитировать.
В игре есть механика заточки оружия, платим деньги — получаем улучшенное оружие.
Теперь берем адрес памяти, в котором хранятся деньги, подключаем дебаггер к игре и просим его оставить выполнение программы, если она попытается изменить значение переменной в следующий раз.
Далее мы поднимаемся немного наверх, добираемся до начала функции и попеременно меняем условия, которые в дебаггере подсвечиваются желтым цветом. 
Опытным путем мы узнаем, что если третье условие сработает, то мы не потратим деньги. 
Почему? Хороший вопрос, для этого надо проследить ход выполнения программы более внимательно, но результат не хочет ждать, поэтому вместо условия jl ставим безусловный переход командой jmp и наслаждаемся бесплатными улучшениями.
Еще в игре есть досадная ошибка разработчиков, влияющая на баланс, — оружие можно улучшать только на пять уровней выше персонажа. 
Что ж, исправим это!
Первым делом необходимо найти в памяти уровень персонажа. 
Это можно сделать предварительно накрутив себе опыта. 
Как только у нас есть информация об уровне персонажа, мы снова любезно просим дебаггер приостановить работу игры в момент обращения к памяти по этому адресу.
Как правило, в основе работы крэкера лежит исследование ассемблерного кода, полученного из машинных инструкций с помощью специально предназначенной для этого программы-дизассемблера. В зависимости от выбранного способа взлома результат исследования может использоваться, например, для построения генератора ключей или для внесения необходимых изменений в исполняемый файл. Последний способ в большинстве случаев наиболее лёгкий, так как не требует изучения алгоритма проверки правильности ключа: зачастую взлом сводится к поиску проверки нескольких условий (наподобие «ВведённоеЧисло равно ЭталонномуЧислу?») и замене такого условия на безусловный переход (goto, jmp), или, реже, на противоположное (то есть для данного примера на «Введённое Число не равно Эталонному Числу?»).
Кроме того, внесение изменений в исполняемый файл (патч) может производиться с целью отключения нежелательных действий со стороны программы (например, напоминание о необходимости регистрации), сокращения функциональности программы. В этих случаях соответствующие команды процессору часто заменяются на байты со значением 90h (в шестнадцатеричной системе счисления), что соответствует ассемблерной команде nop (no operation), то есть «пустой команде», не выполняющей никаких действий. 
Если таких команд много, то применяется безусловный переход (перепрыгивание через ненужный код). 
Возможно также расширение возможностей программы написанием дополнительного кода, но, как правило, это слишком трудоёмкий процесс, не оправдывающий временных затрат.
Между тем, патч возможен, как правило, в том случае, когда исполняемый файл программы не защищён специальными «пакерами» и «протекторами» — программами, скрывающими реальный код исполняемого файла. Для последнего типа программ зачастую используется самая интеллектуальная часть обратной разработки (англ. reverse engineering) — исследование кода программы при помощи отладчика и создание генератора ключей, но возможны и другие решения, например, создание загрузчика.